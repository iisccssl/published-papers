\mysection{Implementation in Firefox}
\label{section:implementation}

We implemented \txjs\ by modifying Firefox (version 3.7a4pre). Overall, our
prototype adds or modifies about $6,\!400$ lines of code in the browser
\footnote{\newadd{Transcript's design does not impose any fundamental
restrictions on JITing of code within a transaction. However, to ease the
development effort for our Transcript prototype, we chose not to handle JITed
code paths in the prototype.}}. The bulk of this section describes \txjs's
enhancements to SpiderMonkey (Firefox's \js\ interpreter)
(\sectref{section:implementation:spidermonkey}) and its support for speculative
DOM updates (\sectref{section:implementation:txdom}). We also discuss \txjs's
support for conflict detection
(\sectref{section:implementation:auxiliary:conflicts}) and the need to modify
the \html{script} tag (\sectref{section:implementation:auxiliary:script}).

%------------------------------------------------------------------------------
\mysubsection{Enhancements to SpiderMonkey} 
\label{section:implementation:spidermonkey}

Our prototype enhances SpiderMonkey in five ways:

\begin{figure*}[t]
%\vspace*{-3.0ex}
\setlength{\tabcolsep}{2pt}
\centering
\scriptsize
\begin{tabular}{|l|l|}
\hline
\textbf{API}         & \textbf{Description} \\ 
\hline
\codetiny{getReadSet}    & Exports transaction's read set to \js.\\
\codetiny{getWriteSet}   & Exports transaction's write set to \js.\\
\codetiny{getTxDocument} & Returns a reference to the speculative
\code{document} object.\\
\codetiny{isSuspended}   & Returns \code{true} if the transaction is
suspended.\\
\codetiny{getCause}      & Returns cause of a transaction suspend.\\
\codetiny{getObject}     & Returns object reference on which a suspension was
invoked.\\
\codetiny{getArgs}       & Returns set of arguments involved in a transaction
suspend.\\
\codetiny{resume}        & Resumes suspended transaction.\\
\codetiny{glueresume}    & Resumes suspended transaction and glues execution
contexts.\\
\codetiny{isDOMConflict} & Checks for conflicts between the host's and cloned
DOM.\\
\codetiny{isHeapConflict}& Checks for conflicts between the host and guest
heaps.\\
\codetiny{commit}        & Commits changes to host's \js\ heap and DOM.\\
\hline
\end{tabular}
\mycaptionsquish{Key APIs defined on the transaction object.}
{\label{figure:txAPIs}}
%\vspace*{-3.0ex}
\end{figure*}

%\begin{wrapfigure}{rh}{0.625\textwidth}
%\vspace*{-3.0ex}
%\setlength{\tabcolsep}{2pt}
%\centering
%\scriptsize
%\begin{tabular}{|l|l|}
%\hline
%\textbf{API}         & \textbf{Description} \\ 
%\hline
%\codetiny{getReadSet}    & Exports transaction's read set to \js.\\
%\codetiny{getWriteSet}   & Exports transaction's write set to \js.\\
%\codetiny{getTxDocument} & Returns a reference to the speculative
%\code{document} object.\\
%\codetiny{isSuspended}   & Returns \code{true} if the transaction is
%suspended.\\
%\codetiny{getCause}      & Returns cause of a transaction suspend.\\
%\codetiny{getObject}     & Returns object reference on which a suspension was
%invoked.\\
%\codetiny{getArgs}       & Returns set of arguments involved in a transaction
%suspend.\\
%\codetiny{resume}        & Resumes suspended transaction.\\
%\codetiny{glueresume}    & Resumes suspended transaction and glues execution
%contexts.\\
%\codetiny{isDOMConflict} & Checks for conflicts between the host's and cloned
%DOM.\\
%\codetiny{isHeapConflict}& Checks for conflicts between the host and guest
%heaps.\\
%\codetiny{commit}        & Commits changes to host's \js\ heap and DOM.\\
%\hline
%\end{tabular}
%\mycaptionsquish{Key APIs defined on the transaction object.}
%{\label{figure:txAPIs}}
%\vspace*{-3.0ex}
%\end{wrapfigure}

\noindent$\bullet$
\textit{Transaction objects.} We added a new class of \js\ objects to
denote transactions. This object stores a pointer to the read/write sets,
activation records of the transaction, and to the cloned DOM. It implements the
builtin methods shown in \figref{figure:txAPIs}.


\noindent$\bullet$
\textit{A \texttt{transaction} keyword.} We added a \code{transaction}
keyword to the syntax of \js. When the \txjs-enhanced \js\ parser encounters
this keyword, it (a)~compiles the body of the transaction into an anonymous
function; (b)~inserts a new instruction, \textsf{JSOP\_BEGIN\_TX}, into the
generated bytecode to signify the start of a transaction; and (c)~inserts code
to invoke the anonymous function.  The transaction ends when the anonymous
function completes execution. Finally, the anonymous function returns a
transaction object when it suspends or completes execution.

\noindent$\bullet$
\textit{Read/write sets.} \txjs\ adds read/write set-manipulation to the
interpretation of several \js\ bytecode instructions. We enhanced the
interpreter so that each bytecode instruction that accesses or modifies \js\
objects additionally checks whether its execution is within a transaction
(\ie~if an unfinished \textsf{JSOP\_BEGIN\_TX} was previously encountered in
the bytecode stream). If so, the execution of the instruction also logs an
identifier denoting the \js\ object (or property) accessed/modified in its
read/write sets, which we implemented using hash tables.  We used
SpiderMonkey's identifiers for \js\ objects; references using aliases to the
same object will return the same identifier.

\noindent$\bullet$
\textit{Suspend.} We modified the interpreter's implementation of
bytecode instructions that perform external operations and register event
handlers to suspend when executed within a transaction. The suspend operation
and the builtin \code{resume} function of transaction objects are implemented
as shown in \figref{figure:workflow}. We also introduced a \code{suspend}
construct that allows hosts to customize transaction suspension. Hosts can
include this construct within a transaction (before including guest code) to
register custom suspension points.  The call \code{suspend [obj.foo]} suspends
the transaction when it invokes \code{foo} (if it is a method) or attempts to
read from or write to the property \code{foo} of \code{obj}.

\noindent$\bullet$
\textit{Garbage Collection.} We interfaced \txjs\ with the garbage collector to
traverse and mark all heap objects that are reachable from live transaction
objects. This avoids any inadvertent garbage collection of objects still
reachable from suspended transactions that could be resumed in the future.

%\remove{
Integrating these changes into a legacy \js\ engine proved to be a
challenging exercise. We refer interested readers to
Appendix~\ref{section:appendix:tail-call} for a description of how our
implementation addressed one such challenge, non-tail recursive calls in
SpiderMonkey.
%}

%------------------------------------------------------------------------------
\mysubsection{Supporting speculative DOM updates} 
\label{section:implementation:txdom}

\txjs\ provides each executing transaction with its private copy of the host's
document structure and uses this copy to record all DOM changes made by guest
code. This section presents notable details of the implementation of \txjs's
DOM subsystem.

\txjs\ constructs a replica of the host's DOM when it encounters a
\textsf{JSOP\_BEGIN\_TX} instruction in the bytecode stream. It clones nodes in
the host's DOM tree, and iterates over each node in the host's DOM to copy
references to any event handlers and dynamically-attached \js\ properties
associated with the node. If a guest attempts to modify an event handler
associated with a node, the reference is rewritten to point to the function
object in the transaction's write set.

Crom~\cite{crom:nsdi10} also implemented DOM cloning for speculative
execution (albeit not for the purpose of mediating untrusted code).  Unlike
Crom, which implemented DOM cloning as a \js\ library, \txjs\ implements
cloning in the browser itself. This feature simplifies several issues that
Crom's designers faced (\eg~cloning DOM-level 2 event handlers) and also allows
efficient cloning.

When a guest references a DOM node within a transaction, \txjs\ transparently
redirects this reference to the cloned DOM. It achieves this goal by modifying
the browser to tag each node in the host's DOM with a unique identifier
(\code{uid}). During cloning, \txjs\ assigns each node in the cloned DOM the
same \code{uid} as its counterpart in the host's DOM.  When the guest attempts
to access a DOM node, \txjs\ retrieves the \code{uid} of the node and walks the
cloned DOM for a match. We defined a \code{getElementByUID} API on the
\code{document} object to return a node with a given \code{uid}. 

% When \txjs\ clones the host's DOM, the cloned copy remains in browser
% memory and does not have an associated output stream. However, guests may
% inject new DOM nodes using \code{document.write}, as in
% \figref{figure:motivate}. Normally, the browser parses the text argument of
% \code{document.write} as HTML and writes the result to the output stream
% associated with the document in the current window. When a guest in a
% transaction attempts a \code{document.write}, the operation suspends and traps
% into the iblock of the host, which must use \code{document.parse} to parse the
% HTML. Without an associated output stream, however, \code{document.parse} will
% be unable to make the necessary updates to the cloned DOM. To address this
% problem, \txjs's implementation of \code{document.parse}
% %
% (a)~creates and attaches a temporary \html{iframe} element to the host
% document; 
% %
% (b)~creates the DOM tree for the parsed HTML (\ie~the argument to
% \code{document.parse}) and appends it to the \html{iframe} body; 
% %
% (c)~imports the \html{iframe}'s document structure into the guest transaction's
% cloned DOM; and 
% %
% (d)~deletes the \html{iframe}.  The \html{iframe} therefore serves as a
% temporary output stream for the cloned DOM.  

If the guest's operations conform to the host's policies, the host commits the
transaction, upon which \txjs\ replaces the host's DOM with the transaction's
copy of the DOM, thereby making the guest's speculative changes visible to the
host. 

\mysubsection{Conflict detection}
\label{section:implementation:auxiliary:conflicts}
%
When a host decides to commit a transaction, \txjs\ will replace the host's DOM
with the guest's DOM. Objects on the host's heap are also overwritten using the
write set of the guest's transaction.  During replacement, care must be taken
to ensure that the host's state is consistent with the guest's state. Consider,
for instance, a guest that performs an \code{appendChild} operation on a DOM
node (say node \texttt{N}).  This operation causes a new node to be added to
the cloned DOM, and also suspends the guest transaction.  However, the host may
delete node \texttt{N} before resuming the transaction; upon resumption, the
guest continues to update a stale copy of the DOM (\ie~the cloned version).
When the transaction commits, the removed DOM node will be added to the host's
DOM.

\begin{wrapfigure}{rh}{0.575\textwidth}
%\vspace*{-3.0ex}
\setlength{\tabcolsep}{1pt}
\centering
%\begin{center}
\renewcommand{\arraystretch}{0.65}
\begin{tabular}{|rl|}
\hline
 & \codetiny{function hasParent(txNode) \{}\\
 & \mytab \codetiny{var parent = txNode.parentNode;}\\
 & \mytab \codetiny{if (document.getElementByUID(parent.uid) != null)
return true;}\\
 & \mytab \codetiny{else return false;}\\
 & \codetiny{\} ...}\\
 & \codetiny{var isAllowed = tx.isDOMConflict(hasParent); // tx is the
transaction object}\\
\hline
\end{tabular}
%\end{center}
%\indent\vspace{-0.5cm}
\mycaptionsquish{Example showing conflict detection.}{\label{figure:conflict}}
%\vspace*{-3.0ex}
\end{wrapfigure}
%
\txjs\ adds the \code{isDOMConflict} and \code{isHeapConflict} APIs to the
transaction object, which allow host developers to register conflict detection
policies. When invoked in the host's iblock, the \code{isDOMConflict} API
invokes the conflict detection policy on each DOM node speculatively modified
within the transaction (using the transaction's write set to identify nodes
that were modified). The \code{isHeapConflict} API likewise checks that the
state of the host's heap matches the state of the guest's heap at the start of
the transaction.  The snippet in \figref{figure:conflict} shows one example of
such a conflict detection policy (using \code{isDOMConflict}) encoded in the
host's iblock that verifies that each node speculatively modified by the guest
(\code{txNode}) has a parent in the host's DOM.
%

While \txjs\ provides the core \textit{mechanisms} to detect transaction
conflicts, it does not dictate any \textit{policies} to resolve them. The
host must resolve such conflicts within the application-specific part of its
iblocks.
%------------------------------------------------------------------------------
\mysubsection{The \texttt{<script>} tag}
\label{section:implementation:auxiliary:script}
%
The examples presented thus far show hosts including guest code by inlining it
within a transaction.  However, hosts typically include guests using
\html{script} tags, \eg~\html{script
src="http://untrusted.com/\linebreak[0]guest.js"}.
\txjs\ also supports code inclusion using \html{script} tags. To do so, it
extends the \html{script} tag so that the fetched code can be encapsulated in a
function rather than run immediately. The host application can use the modified
\html{script} tag as: \html{script
src="http://\linebreak[0]untrusted.com/guest.js" func="foobar"}. This tag
encapsulates the code in \code{foobar}, which the host can then invoke within a
transaction. 

By itself, this modification unfortunately affects the scope chain in which the
fetched code is executed.  \js\ code included using a \html{script} tag expects
to be executed in the global scope of the host, but the modified \html{script}
tag would put the fetched code in the scope of the function specified in the
\code{func} attribute (\eg~\code{foobar}).

We addressed this problem using a key property of \code{eval}.  The ECMAScript
standard~\cite[Section 10.4.2]{ecma} specifies that an \textit{indirect}
\code{eval} (\ie~via a reference to the \code{eval} function) is executed in
the global scope. We therefore extracted the body of the compiled function
\code{foobar} and executed it using an indirect \code{eval} call within a
transaction (see \figref{figure:txwebapp}). This transformation allowed all
variables and functions declared in the function \code{foobar} to be
speculatively attached to the host's global scope.
