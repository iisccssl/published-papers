\begin{figure*}
\footnotesize
\centering
\begin{tabular}{|l|c|c|c|c|c|c|}
\hline
\multicolumn{1}{|c|}{\bf Library} &
  {\bf \scriptsize \#Classes} &
  {\bf \scriptsize \#Methods} &
  {\bf \scriptsize \#Tests} &
%  {\bf \scriptsize \#Inconsistencies} & % Data to be supplied by Nader.
  \multicolumn{3}{c|}{\underline{\bf \scriptsize \#Inconsistencies (by type)}}\\
%& & & & & {\bf \scriptsize Type 1} & {\bf \scriptsize Type 2} & {\bf \scriptsize Type 3}\\
& & & & {\bf \scriptsize Type 1} & {\bf \scriptsize Type 2} & {\bf \scriptsize Type 3}\\
\hline
\hline
\code{Microsoft.CSharp} & 
%  6    &   56   &  1,848  &     0 & 0 &  0  & 0\\
  6    &   56   &  1,848  &      0 &  0  & 0\\
\code{Microsoft.VisualBasic} & 
%  17   &  127   &    613  &     0 & 0 &  0  & 0\\
  17   &  127   &    613  &      0 &  0  & 0\\
\code{System.Collections.Concurrent} & 
%  10    &   77   &   349  &     0 & 0 &  0  & 0\\
  10    &   77   &   349  &     0 &  0  & 0\\
\code{System.Collections} & 
%  29    &  172   &   532  &     0 & 0 &  0  & 0\\
  29    &  172   &   532  &     0 &  0  & 0\\
\code{System.ComponentModel} & 
%   5    &    4   & 1,578  &     0 &  0 &  0  & 0\\
   5    &    4   & 1,578  &     0 &  0  & 0\\
\code{System.Dynamic.Runtime} & 
%  29   &   201   &   790  &     4 &  1 &  0  & 0\\
  29   &   201   &   790  &      1 &  0  & 0\\
\code{System.Globalization} & 
%  14   &   288   &   567  &    29 &  3 &  3  & 0\\
  14   &   288   &   567  &     3 &  3  & 0\\
\code{System.Linq} & 
%  5    &   172   &   591  &     0 &  0 &  0  & 0\\
  5    &   172   &   591  &       0 &  0  & 0\\
\code{System.Linq.Expressions} & 
%  44   &   633   &   590  &     6 &  1 &  0  & 1\\
  44   &   633   &   590  &       1 &  0  & 1\\
% \code{System.Linq.Parallel} & 
%  6   &   195  & ??    &  X & 0 &  0  & 0\\
\code{System.Net.Http} & 
%  44   &   524   &   746  &    21 &  3 &  0  & 3\\
  44   &   524   &   746  &     3 &  0  & 3\\
\code{System.Net.NetworkInformation} & 
%  1   &      1   &     1  &     0 &  0 &  0  & 0\\
  1   &      1   &     1  &       0 &  0  & 0\\
\code{System.Net.Primitives} & 
%  13   &   105   &   956  &    30 &  0 &  1  & 1\\
  13   &   105   &   956  &     0 &  1  & 1\\
\code{System.Net.Requests} & 
%  10    &  122   & 1,269  &     0 &  0 &  0  & 0\\
  10    &  122   & 1,269  &      0 &  0  & 0\\
\code{System.ObjectModel} & 
%  16   &    52   & 1,573  &     0 &  0 &  0  & 0\\
  16   &    52   & 1,573  &      0 &  0  & 0\\
\code{System.Reosurces.ResourceManager} & 
%  4    &    28   & 1,333  &    46 &  0 &  1  & 0 \\
  4    &    28   & 1,333  &     0 &  1  & 0 \\
\code{System.Runtime.Extensions} & 
%  12   &   409   &  946   &    28 &  3 &  1  & 1\\
  12   &   409   &  946   &     3 &  1  & 1\\
\code{System.Runtime.Numerics} & 
%   2   &   170   & 1,514  &    35 &  3 &  0  & 2\\
   2   &   170   & 1,514  &     3 &  0  & 2\\
\code{System.Runtime.Serialization.Json} & 
%   4   &    37   & 1,642  &   940 &  1 &  0  & 0\\
   4   &    37   & 1,642  &    1 &  0  & 0\\
\code{System.Runtime.Serialization.Primitives} & 
%  13   &    86   & 1,387  &     5 &  1 &  0  & 1\\
  13   &    86   & 1,387  &      1 &  0  & 1\\
\code{System.Runtime.Serialization.Xml} & 
%  14   &   342   &  420   &    63 &  1 &  3  & 1\\
  14   &   342   &  420   &     1 &  3  & 1\\
\code{System.Text.Encoding} & 
%   5   &    66   &  940   &     5 &  1 &  0  & 0\\
   5   &    66   &  940   &      1 &  0  & 0\\
\code{System.Text.RegularExpressions} & 
%  10   &   103   &  848   &     0 &  0 &  0  & 0\\
  10   &   103   &  848   &      0 &  0  & 0\\
\code{System.Xml.ReaderWriter} & 
%  24   &   346   &  820   &    51 &  2 &  3  & 3\\
  24   &   346   &  820   &     2 &  3  & 3\\
\code{System.Xml.XDocument} & 
%  23   &   637   &  612   &    47 &  0 &  1  & 1\\
  23   &   637   &  612   &     0 &  1  & 1\\
\hline
\hline
\multicolumn{1}{|c|}{\bf ~} &
  {\bf ~}   & % {\bf 360} &
  {\bf ~} & % {\bf 4,953} &
  {\bf ~} &
%  {\bf ~} &
  {\bf 20} &
  {\bf 13} &
  {\bf 14}\\
%\cline{6-8}
\cline{5-7}
\multicolumn{1}{|c|}{\bf Total} &
  {\bf 354}   & % {\bf 360} &
  {\bf 4,758} & % {\bf 4,953} &
  {\bf 22,465} &
%  {\bf 1,310} &
  \multicolumn{3}{c|}{\bf 47}\\
\hline
\end{tabular}
\mycaption{Summary of inconsistencies found by \tool\ in various Xamarin
libraries. This table shows the number of classes in each library and the
number of methods in these classes. It also shows the number of test cases that
\tool\ generated for those libraries, and the number of cases of inconsistent
behavior across platforms. These inconsistencies are sorted by type, as defined in
\figref{table:inconsistency-sources}.}{\label{table:xcheckresults}}
\end{figure*}

\section{Experimental Results}
\label{section:evaluation}

\myparagraph{Setup}
%
For our experimental evaluation, we used Xamarin.Android version 4.16.0,
business edition. We chose Windows 8.1 as the home platform, and Android 4.0.3
(API level 15) as the target platform. As discussed in
\sectref{section:implementation}, we generate test cases on a desktop version
of Windows, and then run these cases on Windows Phone and Android platforms.
Both the phone and desktop version of Windows use \code{.NET} version
4.5.51641. We use Visual Studio Ultimate 2013 version 12.0.30501 as the IDE to
compile our test cases. This environment supports a package that integrates the
tools for Windows Phone 8.1 into the controls of Visual Studio. We also use the
same development environment to build the Android version using Xamarin. In
particular, we use the Xamarin 3.5.58.0 extension to enable development for
Xamarin.Android within Visual Studio.

We use emulators to mimic Windows Phone and Android devices. Microsoft offers a
few pre-configured emulation environments for Windows Phone: our experiments
use Emulator 8.1/WVGA-4inch/512MB configuration. We configured the Android
emulator to match the hardware configurations of the Windows Phone emulator.
% All experiments on Intel Core-i7-3770 at 3.4GHz, 16GB RAM, Windows 8.1 Pro.

\myparagraph{Examples of Inconsistent Behavior}
%
\figref{table:xcheckresults} presents the results of our experiments.  To date,
we have used \tool\ to generate \checkme{22,465} test cases, which invoke
\checkme{4,758} methods implemented in \checkme{354} classes across
\checkme{24} Xamarin DLLs. In all, we observed \checkme{47} unique instances of
inconsistent behavior across Windows Phone and Android.  The results also show
a detailed breakdown of these inconsistencies by category, where the type of
the inconsistency is as defined in \figref{table:inconsistency-sources}. 
% A large number of these instances (\checkme{940}) stemmed from a single root
% cause in the test cases for \code{System.Runtime.Serialization.Json}.

In most cases, we were quickly able to quickly confirm using MSDN and Xamarin
documentation that the inconsistency was indeed a bug in Xamarin. For each type
of inconsistency in \figref{table:inconsistency-sources}, the test cases that
induced them and the inconsistent results they produced were largely similar to
the examples described in \sectref{section:example}. We now discuss a few
interesting examples of inconsistencies that we found.

\begin{mylist}
%
\item \textit{Precision in math libraries.} We observed two inconsistencies
that were related to precision with which math libraries used rounding and
precision to represent numbers. In one test case, a call to
\code{System.Math.IEEERemainder(double x, double y)} was invoked with
\code{x}=\code{1.49089193085384E-81} and \code{y}=\code{2.22275874948508E-162}.
The Windows Phone version returns a result of \code{3.33639470813326E-163},
while the Android version produced by Xamarin returns \code{0}. 

The second test case was a method sequence with two calls. The first call,
\code{System.Math.Round}\code{(Decimal d, int i, MidpointRounding mode)} was
invoked in the test case as \code{System.Math.Round(2, 3, ToEven)}. According
to the documentation, this call returns the value \code{d} rounded with
\code{i} fractional digits in the given \code{mode}. The Windows Phone version
returns \code{2.000} while the Android version returns \code{2}. While these
are equivalent if used in a mathematical calculation, the second call in the
test case converted them to strings using \code{System.Convert.ToString}, which
resulted in inconsistent serialized state. These examples highlight
inconsistent handling of floating point arithmetic across platforms.

\item \textit{Ambiguous documentation of exception semantics.} We observed one
test case where different exceptions were raised for the same failing method
call because of ambiguity in the semantics of the exception to be raised.
According to documentation, the \code{NameTable.Add}\code{(Char[] key, int
start, int len)} call can throw two types of exceptions. It throws
\code{IndexOutOfRangeException} when any one of these three conditions is met:
0$>$\code{start}, \code{start}$\geqslant$\code{key.Length}, or
\code{len}$\geqslant$\code{key.Length}. It throws
\code{ArgumentOutOfRangeException} if \code{len}$<$0.

In one of our test cases, the values of \code{start} and \code{len} were such
that 0$>$\code{start} and \code{len}$<$0. For this test case, both the Windows
Phone and desktop versions threw \code{IndexOutOfRangeException} whereas
Xamarin's Android code threw \code{ArgumentOutOfRangeException}. Although both
implementations are correct, the documentation must be clarified to remove this
ambiguity.

\item \textit{Documented deviations of behavior.} For some methods,
documentation specifies that the behavior of the method will vary across
platforms. Thus, the Xamarin and \code{.NET} implementations of these methods
need not be similar.  For example, consider the constructor for the
\code{UriBuilder} class. The documentation specifies that if this class is
implemented in a PCL, then if an invalid URI is provided as the string argument
to the constructor, it must throw a \code{FormatException} instead of a
\code{UriFormatException}.

We also observed examples where the deviations in behavior were not specified
formally in the documentation, but were known to the developers of the
platform. One such example is the method \code{ReadContentAsString} from the
class \code{XmlDictionaryReader}. When included in a test case, this method
showed inconsistent behavior across the Windows Phone and Android versions.
However, when we tried to identify the cause of this bug by examining the
source code of the Mono platform (which Xamarin extends to provide a
cross-platform implementation of \code{.NET}), we found that it was marked with
a \code{MonoTODO} attribute, indicating a known issue with its implementation.

We were not aware of these documented deviations in behavior when we tested the
methods using \tool, and the resulting differences were reported as
inconsistencies. However, because the documentation (or code comments) did
specify that the inconsistencies were expected across platforms, we do not
count these as bugs (and therefore they do not factor into the 47
inconsistencies reported in \figref{table:xcheckresults}).  Nevertheless, we
feel that for such methods, the deviations of behavior should be encoded more
explicitly (\eg~as pre-conditions) rather than being latent in documentation or
in code comments.
%
\end{mylist}


\myparagraph{Performance}
%
Finally, we report the time taken to run test cases on our experimental setup.
We ran the Windows Phone and Android emulators on a desktop system running
Windows 8.1 professional edition, and equipped with an Intel Core-i7-3770
running at 3.4GHz, 16GB of RAM. We created an app that packaged 1000
randomly-generated tests and ran the Windows Phone and Android versions of this
app on both emulators. The Android emulator took 29.1 seconds to run the app,
while the Windows Phone emulator took 2.7 seconds. The Android emulator is much
slower because it emulates the ARM architecture atop our Intel platform. In
contrast, the Windows Phone ``emulator'' uses hyper-V and is implemented as a
virtual machine.
