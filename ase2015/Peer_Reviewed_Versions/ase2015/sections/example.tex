\section{Motivating Examples}
\label{section:example}

In this section, we present a few motivating examples of real inconsistencies
that \tool\ found in Xamarin. For our examples, we use Android as the target
platform; the default home platform is Windows phone.  We use these examples to
motivate some design features of \tool, and classify the types of
inconsistencies that it can identify. 

\figref{figure:serializer-eg} shows a test case generated by \tool. This code
is in C\# and uses classes and methods from the Windows Phone SDK. In this test
case, the code first creates two objects, \code{base} and \code{exp}, from the
\code{Systems.Numerics.Complex} class, and initializes them to $0$+$0i$ and
$1$+$0i$. On line~(8), it uses the \code{Complex.Pow} operation to raise
\code{base} to the power of \code{exp}.

\begin{figure}[t!]
\centering
\fontsize{5.5pt}{5.5pt}
\selectfont
\begin{tabular}{|r@{~}l|}
\hline
{\tiny \bf (1)} &
\code{using System.Numerics;}\\
{\tiny \bf (2)} &
\code{Serializer serializer; // Serializer is a data structure serializer.}\\
{\tiny \bf (3)} &
\code{public class TestCase \{}\\
{\tiny \bf (4)} &
\tab
  \code{public static int TestMain (MyFileIO serialStream, MyFileIO logStream) \{}\\
{\tiny \bf (5)} &
\tab\tab
    \code{try \{}\\
{\tiny \bf (6)} &
\tab\tab\tab
      \code{Complex base = new Complex(0,0);}\\
{\tiny \bf (7)} &
\tab\tab\tab
      \code{Complex exp = new Complex(1,0);}\\
{\tiny \bf (8)} &
\tab\tab\tab
      \code{Complex res = Complex.Pow(base,exp);}\\
{\tiny \bf (9)} &
\tab\tab\tab
      \code{serialStream.append(base.GetType().FullName, serializer.serialize(base));}\\
{\tiny \bf (10)} &
\tab\tab\tab
      \code{serialStream.append(exp.GetType().FullName, serializer.serialize(exp));}\\
{\tiny \bf (11)} &
\tab\tab\tab
      \code{serialStream.append(res.GetType().FullName, serializer.serialize(res));}\\
{\tiny \bf (12)} &
\tab\tab\tab
      \code{return} \textsc{success;}\\
{\tiny \bf (13)} &
\tab\tab
    \code{\} catch (System.Exception e) \{}\\
{\tiny \bf (14)} &
\tab\tab\tab
      \code{logStream.append(e.GetType().FullName);}\\
{\tiny \bf (15)} &
\tab\tab\tab
      \code{return} \textsc{exception;}\\
{\tiny \bf (16)} &
\tab\tab
    \}\\
{\tiny \bf (17)} &
\tab
  \}\\
{\tiny \bf (18)} &
\}\\
\hline
\end{tabular}
\mycaption{A test case that illustrates inconsistent handling of the semantics
of the Windows Phone SDK. The values of \code{res} are different in the Windows
Phone and the Xamarin-produced Android versions of this
code.}{\label{figure:serializer-eg}}
\end{figure}

We used the Visual Studio toolkit and the Xamarin framework to produce a
Windows Phone app and an Android app, respectively, and ran the apps on the
corresponding platforms. Both apps execute and return \textsc{success}.
However, in the Windows Phone app, the value of \code{res} is $0$+$0i$, while
on the Android app, the value is \code{NAN} (not a number). This is clearly an
inconsistency in the way the two apps handled the semantics of the
\code{Complex.Pow} operation.  Since we reported this bug on Xamarin's BugZilla
forum, it has been fixed in the master branch for the next
release~\cite{xam:bzil:28562}.

In this example, eliciting the inconsistent behavior between the Windows Phone
and the Android versions of the app requires the calls on lines~(6)-(8), with
the corresponding data dependencies. To systematically uncover more examples of
such inconsistencies, \tool\ must therefore generate many more such test cases
by systematically invoking methods from the API of the Windows Phone SDK with
suitable arguments.

When the apps produced from these test cases are executed on their
corresponding platforms, inconsistent behavior may manifest itself in one of
three ways (\figref{table:inconsistency-sources}). The first way, as
illustrated in the example in \figref{figure:serializer-eg}, is where the test
case returns \textsc{success} on both platforms, but the resulting state is
different.  Such inconsistencies are latent in the state of the apps, in this
case, the values of the objects, and are not visible unless this state is made
explicit and compared across the two versions. 

%\newcommand{\checkmark}{$\surd$}

\begin{figure}[t!]
\centering
\small
\begin{tabular}{|c|c|c|l|c|}
\hline
\textbf{\scriptsize Type} &
  \textbf{\scriptsize Platform~1} &        
  \textbf{\scriptsize Platform~2} &
  \textbf{\scriptsize Consistency checks} &
  \textbf{\scriptsize Example}\\
\hline
\textbf{\scriptsize (1)} &
  $\checkmark$ & 
  $\checkmark$ &      
  Check app state &
  \figref{figure:serializer-eg}\\
\textbf{\scriptsize (2)} &
  $\times$ & 
  $\times$ &    
  Check exception code &
  \figref{figure:exception-eg}\\
\textbf{\scriptsize (3)} &
  $\checkmark$ &  
  $\times$ & 
  Always inconsistent &
  \figref{figure:inconsist-eg}\\
\hline
\end{tabular}
\mycaption{Different ways in which a test case produced by \tool\ can exhibit
inconsistent behavior when executed on two platforms.
$\checkmark$ denotes that the test case returns
\textsc{\sc success}, while $\times$ denotes that the test case returns
\textsc{\sc exception}.}
{\label{table:inconsistency-sources}}
\end{figure}

\tool\ achieves this goal by \textit{serializing} all objects that are
reachable from the variables that are in scope within the source code of the
app. Lines~(9)-(11) in \figref{figure:serializer-eg} show the objects being
serialized and appended to a log.  \tool\ compares the logs produced by the
Windows Phone and the Android versions of the apps to identify inconsistencies.
In this example, serializing the \code{Complex} object simply prints its value
to the log. However, \tool's serializer supports arbitrary data types, and
serializes them in a custom format. The serializer itself is written in C\#,
with calls to the Windows Phone SDK, and is included as a library within the
native app. As with all our test cases, we use Xamarin to produce the Android
version of the serialization library. Because \tool's test cases include calls
to the serializer in the source code of the test case, we expect the serialized
versions of similar objects to also be similar on the Windows Phone and Android
versions.

A second way for inconsistencies to manifest is when a test case returns
\textsc{exception} on both platforms, but the exceptions thrown are different
on both platforms.  \figref{figure:exception-eg} illustrates a test case in
which this scenario occurs. The call on line~(6) throws an exception because
the value of \code{index} is negative. However, the Windows Phone version
throws a \code{System.ArgumentOutOfRangeException}, while the Android version
throws a \code{System.IndexOutOfRangeException}. In this case, the Windows
Phone and Android versions are inconsistent in the way they handle the
semantics of the \code{GetNumericValue} method. \tool\ therefore logs the
exception code, and compare it across executions of the apps on the two
platforms. This bug has also been
fixed in the master branch for the next release~\cite{xam:bzil:25895}.

\begin{figure}[t!]
\fontsize{5.5pt}{5.5pt}
\selectfont
\centering
\begin{tabular}{|r@{~}l|}
\hline
{\tiny \bf (1)} &
\code{public class TestCase \{}\\
{\tiny \bf (2)} &
\tab
  \code{public static int TestMain (MyFileIO serialStream, MyFileIO logStream) \{}\\
{\tiny \bf (3)} &
\tab\tab
    \code{try \{}\\
{\tiny \bf (4)} &
\tab\tab\tab
      \code{string s = "test";}\\
{\tiny \bf (5)} &
\tab\tab\tab
      \code{Int32 index = -1;}\\
{\tiny \bf (6)} &
\tab\tab\tab
      \code{Double val = System.Globalization.CharUnicodeInfo.GetNumericValue(s, index);}\\
{\tiny \bf (7)} &
\tab\tab\tab
      \code{return} \textsc{success;}\\
{\tiny \bf (8)} &
\tab\tab
    \code{\} catch (System.Exception e) \{}\\
{\tiny \bf (9)} &
\tab\tab\tab
      \code{logStream.append(e.GetType().FullName);}\\
{\tiny \bf (10)} &
\tab\tab\tab
      \code{return} \textsc{exception;}\\
{\tiny \bf (11)} &
\tab\tab
    \code{\}}\\
{\tiny \bf (12)} &
\tab
  \code{\}}\\
{\tiny \bf (13)} &
\code{\}}\\
\hline
\end{tabular}
\mycaption{A test case that triggers an inconsistent exception behavior. In the
Windows Phone version of this code, line~(6) throws a
\code{System.ArgumentOutOfRangeException}, while on the Xamarin-produced
Android version, it throws a
\code{System.IndexOutOfRangeException}. For brevity, we have omitted some code,
such as calls to the serializer.}{\label{figure:exception-eg}}
\end{figure}


In cases such as these, where the test cases on both platforms throw
exceptions, the logs only contain the exception code. In particular, the logs
do not contain the serialized data structures because the calls to the
serializer appear before the \code{return} \textsc{success} statement, and the
exception was raised before control reached the calls to the serializer.  It
may be possible that both the Windows Phone and the Android versions throw the
same exception code, but the state of the data structures in the apps may have
diverged before the code that raised the exception was executed, which is also
an example of inconsistent behavior. As will be clear when we discuss \tool's
approach to test case generation in \sectref{section:design}, \tool\ would have
also identified the divergence of state. In particular, \tool\ uses an
iterative test case generation algorithm that preserves the following property:
any prefix of a method sequence in a test case generated by \tool\ is also a
test case that would have been generated by \tool\ in a previous iteration.
Therefore, if the state is inconsistent after a call sequence preceding the
exception-generating method, it would have been identified as an inconsistency
when the shorter method sequence was used as a test case.

Note that in \figref{figure:exception-eg}, the test case executes the code and
catches a generic \code{System.Exception}. In practice, it may be that a
developer writing a Windows Phone app, familiar with the Windows Phone SDK, may
write this code to catch a \code{System.ArgumentOutOfRangeException}. If he
uses Xamarin to produce an Android app, it is possible for the the inconsistent
behavior to manifest itself in one of the other two forms shown in
\figref{table:inconsistency-sources}.




\begin{figure}[t!]
\fontsize{5.5pt}{5.5pt}
\selectfont
\centering
\begin{tabular}{|rl|}
\hline
{\tiny \bf (1)} &
\code{using System.Xml;}\\
{\tiny \bf (2)} &
\code{public class TestCase \{}\\
{\tiny \bf (3)} &
\tab
  \code{public static int TestMain (MyFileIO serialStream, MyFileIO logStream) \{}\\
{\tiny \bf (4)} &
\tab\tab
    \code{try \{}\\
{\tiny \bf (5)} &
\tab\tab\tab
      \code{NameTable nt1 = new NameTable();}\\
{\tiny \bf (6)} &
\tab\tab\tab
      \code{NameTable nt2 = new NameTable();}\\
{\tiny \bf (7)} &
\tab\tab\tab
      \code{XmlNamespaceManager nsMgr =  new XmlNamespaceManager(nt2); ...}\\
{\tiny \bf (8)} &
\tab\tab\tab
      \code{XmlParserContext xpctxt =  new XmlParserContext(nt1, nsMgr , ...); ...}\\
{\tiny \bf (9)} &
\tab\tab\tab
      \code{return} \textsc{success;}\\
{\tiny \bf (10)} &
\tab\tab
    \code{\} catch (System.Exception e) \{}\\
{\tiny \bf (11)} &
\tab\tab\tab
      \code{logStream.append(e.GetType().FullName);}\\
{\tiny \bf (12)} &
\tab\tab\tab
      \code{return} \textsc{exception;}\\
{\tiny \bf (13)} &
\tab\tab
    \code{\}}\\
{\tiny \bf (14)} &
\tab
  \code{\}}\\
{\tiny \bf (15)} &
\code{\}}\\
\hline
\end{tabular}
\mycaption{A test case that triggers an exception in the Windows Phone version.
The constructor on line~(8) throws an \code{XmlException} because \code{nsMgr}
is independent of \code{nt1}. This test case executes without throwing an
exception on the Xamarin-produced Android version.}
{\label{figure:inconsist-eg}}
\end{figure}


The final possibility for an inconsistency is when a test case returns
\textsc{success} on one platform, and \textsc{exception} on the other.
\figref{figure:inconsist-eg} shows an example of such a test case. The
\code{XmlParserContext} constructor in line~(8) expects its second argument
(\code{nsMgr}) to be created from the first argument (\code{nt1}). However, in
this case, \code{nsMgr} is created from another object \code{nt2}. As a result,
this constructor call must throw an \code{XmlException} according to
Microsoft's documentation, and it does on the Windows Phone version. However,
on the Android version the constructor executes without throwing an exception.
As with the previous two bugs, this one also has been fixed by Xamarin
developers after we reported it~\cite{xam:bzil:27910}.
